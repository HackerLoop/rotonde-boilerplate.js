{
  "name": "rotonde-client",
  "version": "0.0.1",
  "description": "rotonde-client.js is the javascript abstraction above [rotonde](https://github.com/HackerLoop/rotonde). Using abstractions above rotonde is totally optionnal, this project is just here to add a layer of comfort.",
  "main": "src/Client.js",
  "scripts": {
    "build": "gulp build && babel --presets es2015 node --out-dir babelified"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/HackerLoop/rotonde-client.js.git"
  },
  "keywords": [
    "Skybot",
    "Drone",
    "Flylab"
  ],
  "author": {
    "name": "Skybot"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/HackerLoop/rotonde-client.js/issues"
  },
  "homepage": "https://github.com/HackerLoop/rotonde-client.js",
  "devDependencies": {
    "babel-cli": "^6.5.1",
    "babel-preset-es2015": "^6.5.0",
    "babelify": "~5.0.3",
    "browserify": "^6.3.3",
    "gulp": "~3.8.10",
    "gulp-rename": "^1.2.0",
    "rimraf": "~2.2.8",
    "through2": "^2.0.1",
    "vinyl-source-stream": "^1.0.0",
    "watchify": "^2.1.1"
  },
  "dependencies": {
    "lodash": "^2.4.1",
    "promise": "^7.0.4",
    "websocket": "^1.0.21"
  },
  "gitHead": "b08061e812d1d1f56766c9cc7ea400826aa47f68",
  "readme": "## Introduction\n\nrotonde-client.js is the javascript abstraction above [rotonde](https://github.com/HackerLoop/rotonde).\nUsing abstractions above rotonde is totally optionnal, this project is\njust here to add a layer of comfort.\n\nPlease first read the [rotonde](https://github.com/HackerLoop/rotonde) documentation.\n\n# Tutorial #1\n\nThis tutorial is for node, but rotonde-client.js is also available for\nbrowser, build it with `gulp build` in the rotonde-client directory, the\ncompiled javascript will be present in the dist/ directory.\n\nLets write a simple program using rotonde-client.js:\n\n```js\n\n'use strict';\n\nlet newClient = require('rotonde-client/node/rotonde-client');\n\nlet client = newClient('ws://localhost:4224/');\n\nclient.onReady(() => {\n  console.log('connected to rotonde !!!');\n});\n\nclient.connect();\n\n```\n\nThis is the simplest and most useless module.\nLets review is line by line.\n\n```js\nlet newClient = require('rotonde-client/node/rotonde-client');\n```\n\nthe node version is in node/rotonde-client, when you require it, you end up with\na function that creates clients.\n\n```js\nlet client = newClient('ws://localhost:4224/');\n```\n\ncalling the newClient function creates a client, and provides the url of\nthe rotonde server, this call doesn't start the connection.\n\n```js\nclient.onReady(() => {\n  console.log('connected to rotonde !!!');\n});\n```\n\nthis line lets you specify a function to call when the connection is\nestablished, this is the function where everything starts.\n\nWe are now ready to start the connection to rotonde with the `connect`\nmethod.\n\n```js\nclient.connect();\n```\n\nIf the connection is successful, running this small program should just\nprint `connected to rotonde !!!`, and then hang.\n\nThat's not really useful for now, the next tutorial is going to focus on\nthe function that we passed to `onReady`.\n\n# Tutorial #2\n\nNow that we know how to connect to rotonde, we can start using it, or\nmore precisely, start using the other modules connected to it.\n\nIn rotonde, everything you do is send actions and listen for events,\nwhich means that usually the program that you create relies on other\nmodules.\nNow, because you have read the rotonde documentation, you know that the\nfirst thing you receive upon connection with rotonde, is a list of\navailable actions and events.\nThese events and actions describe what is available on the system.\n\nWhich means that, in order to work well, your module first has to make\nsure the events and actions it needs are available.\n\nrotonde-client does this through the `bootstrap` method. The role of the\nbootstrap method is to ease the usual startup procedure of modules,\nwhich usually implies listening incoming definitions, checking if we\nfind the one we need, sending initializing actions, and wait for events\ntelling that everything is initialized properly.\n\nThe `bootstrap` method takes four arguments:\n- `actions`: the list of actions that should be available, and sent when\n  immediately after.\n  The list is given in the form of a map, where the key of each entry is\n  an action identifier, and the value of the entry is the data for the\n  action.\n- `events`: a list of event identifiers that should be available, and received in\n  response to the actions sent; `events` can also be spontaneous.\n- `defs`: a list of additional actions or events identifiers that should\n  be received before starting.\n- `timeout`: ignored is 0, it specifies how long you can wait to receive\n  these events.\n\nFor this tutorial, we will have a look at the serial module [serial-port-json-server](https://github.com/HackerLoop/serial-port-json-server).\n\nThis module lets control the serial ports of your device, it has many\nevents and actions, but the ones that interest us are\n- `SERIAL_OPEN`: the action that opens a serial port\n- `SERIAL_OUTPUT`: the event that reports the result of opening the port\n- `SERIAL_PORTMESSAGE`: the event that is sent when something is\n  received on an openned port.\n\nSo if we want to create a module that uses the serial port, we will\nproceed as follows:\n- wait for the events and actions above to be received.\n- send a `SERIAL_OPEN`.\n- wait for the `SERIAL_OUTPUT' that tells if the open worked or not.\n\nThis steps can be done in one line thanks to the `bootstrap` method:\n\n```js\nclient.bootstrap({'SERIAL_OPEN': openaction}, ['SERIAL_OUTPUT'], ['SERIAL_PORTMESSAGE'])\n```\n\n:)\n\nThis method returns a Promise, if you don't know what it is, read\n[this](https://spring.io/understanding/javascript-promises).\n\n\nNow that you know what a promise is, you know that the next thing to do\nit put the resolve and reject callbacks for this promise:\n\n```js\n// this is the body of the SERIAL_OPEN action\nlet openaction = {\n  port: '/dev/ttyAMA0',\n  baudrate: 9600,\n};\n\nclient.bootstrap({'SERIAL_OPEN': openaction}, ['SERIAL_OUTPUT'], ['SERIAL_PORTMESSAGE']).then((events) => {\n  // this is the success callback\n  console.log('ok, received events:', events);\n}, (error) => {\n  // this is the error callback\n  console.log('error', error);\n});\n```\n\nIf everything went well, you should see the `ok, received events:`\nmessage.\n\nThe `events` argument received in the success callback is the list of\nevents received, in this case, we only specified `SERIAL_OUTPUT` as\nsecond argument to bootstrap, so `events` will only contain one entry,\nwhich is the `SERIAL_OUTPUT` event returned by the serial module upon\nconnection (the `SERIAL_OPEN` action that was first sent).\n\nIt is an event so its structure is as follows:\n\n```js\n{\n  identifier: \"SERIAL_OUTPUT\",\n  data: {\n    ... the data for this event ...\n  }\n}\n```\n(but you only knew this, because you carefully read the rotonde\ndocumentation, which is [here](https://github.com/HackerLoop/rotonde/blob/master/README.md))\n\nThis event's `data` has a `Cmd` field, when the `SERIAL_OPEN` succeeded,\nits value will be `Open`.\nWe can now add the check to the code we wrote:\n\n```js\nlet openaction = {\n  port: '/dev/ttyAMA0',\n  baudrate: 9600,\n};\n\nclient.bootstrap({'SERIAL_OPEN': openaction}, ['SERIAL_OUTPUT'], ['SERIAL_PORTMESSAGE']).then((events) => {\n  // this is the success callback\n  // lets check if the SERIAL_OPEN action succeeded\n  let serialOutputEvent = events[0].data;\n  if (serialOutputEvent.Cmd == 'Open') {\n    console.log('port open, start listening for messages');\n  }\n}, (error) => {\n  // this is the error callback\n  console.log('error', error);\n});\n\n```\n\nThere is one thing missing, we will never know what goes through the\nserial port, because we didn't subscribe to the `SERIAL_PORTMESSAGE`\nevent.\nWe passed it to bootstrap as third argument, but that only ensures that\nit is present on the system before calling the callback.\n\nsubscribing to events is quite easy, you just have to add an handler to\nrotonde-client:\n\n```js\nclient.eventHandlers.attach('SERIAL_PORTMESSAGE', (event) => {\n  console.log(event);\n});\n```\n\n(explanation on what is this `eventHandlers` can be found later in this document).\n\nAdding event handlers can be made before anything, you don't have to be in\nthe `onReady` callback, makes things clearer to me.\n\nNow everything is setup, you can now access your serial ports from\nrotonde.\nAnd more important you can code directly from your dev machine, no need\nto be on the raspberryPI (or any other), you can even code in your\nbrowser to have the Chrome/Firefox debugger available.\n\nThe final code looks like:\n\n```js\n'use strict';\n\nlet newClient = require('rotonde-client/node/rotonde-client');\n\nlet client = newClient('ws://192.168.2.9:4224/');\n\nlet openaction = {\n  port: '/dev/ttyAMA0',\n  baudrate: 9600,\n};\n\nclient.eventHandlers.attach('SERIAL_PORTMESSAGE', (event) => {\n  console.log(event);\n});\n\nclient.onReady(() => {\n  client.bootstrap({'SERIAL_OPEN': openaction}, ['SERIAL_OUTPUT'], ['SERIAL_PORTMESSAGE']).then((events) => {\n    let serialOutputEvent = events[0].data;\n    if (serialOutputEvent.Cmd == 'Open') {\n      console.log('port open, start listening for messages');\n    }\n  }, (error) => {\n    console.log('error', error);\n  });\n});\n\nclient.connect();\n```\n\n# Contributing \n\nYes please.\n\n![](https://d2v4zi8pl64nxt.cloudfront.net/1362775331_b8c6b6e89781c85fee638dffe341ff64.jpg)\n",
  "readmeFilename": "README.md",
  "_id": "rotonde-client@0.0.1",
  "_shasum": "da1f0ffdceaf74418d58fece9e74761e9cfff160",
  "_from": "hackerloop/rotonde-client.js",
  "_resolved": "git://github.com/hackerloop/rotonde-client.js.git#b08061e812d1d1f56766c9cc7ea400826aa47f68"
}
